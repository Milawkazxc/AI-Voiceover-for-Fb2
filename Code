import os
import requests
import json
import uuid
from bs4 import BeautifulSoup
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
from gtts import gTTS
from pydub import AudioSegment
import chardet  # –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–æ–¥–∏—Ä–æ–≤–∫–∏

# === –ù–ê–°–¢–†–û–ô–ö–ò ===
TELEGRAM_TOKEN =  —Å—é–¥–∞ –ø–æ–¥—Å—Ç–∞–≤—å —Å–≤–æ–π —Ç–µ–ª–µ–≥—Ä–∞–º —Ç–æ–∫–µ–Ω "  # –∑–¥–µ—Å—å –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—Å—Ç–∞–≤–∏—Ç—å —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ
OPENROUTER_API_KEY = "—Å—é–¥–∞ –ø–æ–¥—Å—Ç–∞–≤—å —Å–≤–æ–π API –æ—Ç openrouter "   # –∑–¥–µ—Å—å –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—Å—Ç–∞–≤–∏—Ç—å —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ

# === AI-–æ—Ç–≤–µ—Ç —á–µ—Ä–µ–∑ DeepSeek ===
async def ask_ai(question):
    url = "https://openrouter.ai/api/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
        "HTTP-Referer": "https://replit.com/",
        "X-Title": "ReplitBot",
    }
    data = {
        "model": "deepseek/deepseek-chat-v3-0324:free",
        "messages": [{"role": "user", "content": question}],
    }

    response = requests.post(url, headers=headers, data=json.dumps(data))
    response.raise_for_status()
    result = response.json()
    return result["choices"][0]["message"]["content"]

# === –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ ===
def text_to_voice(text):
    tts = gTTS(text=text, lang="ru")
    temp_mp3 = f"{uuid.uuid4()}.mp3"
    temp_ogg = f"{uuid.uuid4()}.ogg"

    tts.save(temp_mp3)
    AudioSegment.from_mp3(temp_mp3).export(temp_ogg, format="ogg", codec="libopus")

    os.remove(temp_mp3)
    return temp_ogg

# === –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ —á–∞—Å—Ç–∏ –ø–æ ~5 –º–∏–Ω—É—Ç ===
def split_text(text, max_chars=3000):
    paragraphs = text.split('\n')
    chunks, current_chunk = [], ""
    for p in paragraphs:
        if len(current_chunk) + len(p) < max_chars:
            current_chunk += p + "\n"
        else:
            chunks.append(current_chunk.strip())
            current_chunk = p + "\n"
    if current_chunk:
        chunks.append(current_chunk.strip())
    return chunks

# === –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ —Ñ–∞–π–ª–∞ ===
def detect_encoding(file_path):
    with open(file_path, "rb") as file:
        raw_data = file.read()
        result = chardet.detect(raw_data)
        return result['encoding']

# === –û–±—Ä–∞–±–æ—Ç–∫–∞ FB2 —Ñ–∞–π–ª–∞ ===
async def handle_fb2(update: Update, context: ContextTypes.DEFAULT_TYPE):
    file = await context.bot.get_file(update.message.document.file_id)
    fb2_path = f"{uuid.uuid4()}.fb2"
    await file.download_to_drive(fb2_path)

    try:
        encoding = detect_encoding(fb2_path)  # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–¥–∏—Ä–æ–≤–∫—É —Ñ–∞–π–ª–∞
        with open(fb2_path, "r", encoding=encoding, errors="ignore") as f:
            soup = BeautifulSoup(f, "xml")
            body = soup.find("body")
            full_text = body.get_text(separator="\n") if body else ""

        parts = split_text(full_text)
        for part in parts:
            voice_path = text_to_voice(part)
            with open(voice_path, "rb") as voice:
                await update.message.reply_voice(voice)
            os.remove(voice_path)
    except Exception as e:
        await update.message.reply_text(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞: {e}")
    finally:
        os.remove(fb2_path)

# === –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π ===
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_message = update.message.text
    try:
        ai_response = await ask_ai(user_message)
        voice_path = text_to_voice(ai_response)
        with open(voice_path, "rb") as voice:
            await update.message.reply_voice(voice)
        os.remove(voice_path)
    except Exception as e:
        await update.message.reply_text(f"–û—à–∏–±–∫–∞: {e}")

# === –ö–æ–º–∞–Ω–¥–∞ /start ===
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ –ª—é–±–æ–π –≤–æ–ø—Ä–æ—Å –∏ —è –æ—Ç–≤–µ—á—É —Ç–µ–±–µ –≥–æ–ª–æ—Å–æ–º –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ fb2 —Ñ–∞–π–ª, –∏ —è –æ–∑–≤—É—á—É —Ç–µ–±–µ —Ç–µ–∫—Å—Ç. –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è –≤ –¥–æ—Ä–æ–≥–µ! üìöüéß")

# === –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ===
if __name__ == "__main__":
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ .fb2
    app.add_handler(MessageHandler(filters.Document.ALL, lambda update, context: handle_fb2(update, context) if update.message.document.file_name.endswith('.fb2') else None))

    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω.")
    app.run_polling()
